{
  "7": {
    "data": "const bgColor=\"#070831\",primaryColor=\"#fff4d6\",secondaryColor=\"#908a76\",maxStepSize=10,maxTrailLength=100;let gridWidth=100,gridHeight=100,history=[],bias=null,biasStrength=5,clickIndicatorRadius=15;function setup(){createCanvas(windowWidth,windowHeight),gridWidth=windowWidth,gridHeight=windowHeight;let i=createVector(windowWidth/2,windowHeight/2);bias=createVector(0,0),history.push(i),stroke(\"#fff4d6\"),noFill(),background(bgColor)}function draw(){background(7,8,49,25);const i=history.length-1;mouseIsPressed&&(bias.x=mouseX-history[history.length-1].x,bias.y=mouseY-history[history.length-1].y,bias.normalize(),bias.mult(biasStrength),circle(mouseX,mouseY,clickIndicatorRadius));let t=history[i].x+random(-10,10)+bias.x,o=history[i].y+random(-10,10)+bias.y;(t<0||t>gridWidth)&&(t=(t+gridWidth)%gridWidth,history=[]),(o<0||o>gridHeight)&&(o=(o+gridHeight)%gridHeight,history=[]);let r=createVector(t,o);history.push(r),history.length>100&&history.shift();for(let i=1;i<history.length;i++)stroke(\"#908a76\"),strokeWeight(2),line(history[i-1].x,history[i-1].y,history[i].x,history[i].y)}function mouseReleased(){bias.x=bias.y=0}function touchEnded(){bias.x=bias.y=0}function windowResized(){resizeCanvas(windowWidth,windowHeight),gridWidth=windowWidth,gridHeight=windowHeight}"
  },
  "8": {
    "data": "class Cell{constructor(t,i,s,r,h,e){this.i=t,this.j=i,this.x=s,this.y=r,this.w=h,this.h=e,this.visited=!1,this.on=!1,this.walls=[!0,!0,!0,!0]}show(){this.visited&&(fill(\"#908a76\"),noStroke(),rect(this.x,this.y,this.w,this.h)),this.on&&(fill(\"#fff4d6\"),noStroke(),rect(this.x,this.y,this.w,this.h)),stroke(255),this.walls[0]&&line(this.x,this.y,this.x+this.w,this.y),this.walls[1]&&line(this.x,this.y,this.x,this.y+this.h),this.walls[2]&&line(this.x,this.y+this.h,this.x+this.w,this.y+this.h),this.walls[3]&&line(this.x+this.w,this.y,this.x+this.w,this.y+this.h)}mark(){this.visited=!0}currentMark(){this.on=!0}currentUnMark(){this.on=!1}checkNeighbours(){let t=[],i=this.i,s=this.j;return i>0&&!grid[i-1][s].visited&&t.push(grid[i-1][s]),i<grid.length-1&&!grid[i+1][s].visited&&t.push(grid[i+1][s]),s>0&&!grid[i][s-1].visited&&t.push(grid[i][s-1]),s<grid[i].length-1&&!grid[i][s+1].visited&&t.push(grid[i][s+1]),t}removeWall(t){if(!t)return;let i=t.i,s=t.j;i<this.i?(this.walls[1]=!1,t.walls[3]=!1):i>this.i?(this.walls[3]=!1,t.walls[1]=!1):s<this.j?(this.walls[0]=!1,t.walls[2]=!1):s>this.j&&(this.walls[2]=!1,t.walls[0]=!1)}}const bgColor=\"#070831\",primaryColor=\"#fff4d6\",secondaryColor=\"#908a76\";let current,grid=[],rows=30,cols=30,gridWidth=300,gridHeight=300,stack=[],offsetX=0,offsetY=0;function setup(){createCanvas(windowWidth,windowHeight),offsetX=(width-gridWidth)/2,offsetY=(height-gridHeight)/2;for(let t=0;t<rows;t++){grid.push([]);for(let i=0;i<cols;i++){let s=new Cell(t,i,t*(gridWidth/rows)+offsetX,i*(gridHeight/cols)+offsetY,gridWidth/rows,gridHeight/cols);grid[t].push(s)}}current=grid[0][0];for(let t=0;t<rows;t++)for(let i=0;i<cols;i++)grid[t][i].show()}function draw(){background(bgColor),current&&current.currentMark(),current&&current.mark();for(let t=0;t<rows;t++)for(let i=0;i<cols;i++)grid[t][i].show();if(!current)return void noLoop();current.currentUnMark();const t=current.checkNeighbours(),i=Math.floor(Math.random()*t.length);let s;t.length>0?(stack.push(current),s=t[i]):stack.length>0&&(s=stack.pop()),s?current.removeWall(s):current.currentUnMark(),current=s}"
  },
  "9": {
    "data": "function satCollision(t,e){const o=[...t.edges.map((t=>createVector(-t.y,t.x).normalize())),...e.edges.map((t=>createVector(-t.y,t.x).normalize()))];let i=1/0;for(let l=0;l<o.length;l++){normal=o[l];let s=1/0,n=-1/0;t.vertices.forEach((t=>{s=min(s,p5.Vector.dot(normal,t)),n=max(n,p5.Vector.dot(normal,t))}));let r=1/0,c=-1/0;if(e.vertices.forEach((t=>{r=min(r,p5.Vector.dot(normal,t)),c=max(c,p5.Vector.dot(normal,t))})),r>n||c<s)return null;i=min(i,min(n,c)-max(s,r))}return e.centre.copy().sub(t.centre).normalize().mult(i)}function staticResolve(t,e,o){let i=o.copy().mult(.5),l=o.copy().mult(-.5),s=o.copy().mult(-1),n=t.movable,r=e.movable,c=t.mass,a=e.mass,h=c+a;n&&r?(t.moveBy(l.mult(a/h)),e.moveBy(i.mult(c/h))):n?t.moveBy(s):r&&e.moveBy(o)}const primaryColor=\"#fff4d6\",secondaryColor=\"#908a76\";class Polygon{constructor(t,e,o,i,l,s,n){this.mass=i,this.color=n?\"#908a76\":color(50),this.defaultColor=this.color,this.movable=n,this.controllable=s,this.maxSpeed=l,this.facingDir=createVector(0,0),this.centre=t,this.distFromCentre=o,this.numVertices=e,this.createShape(e),this.displacement=createVector(0,0)}createShape(){let t=[],e=2*PI/this.numVertices,o=0,i=this.controllable?0:e;for(let l=0;l<this.numVertices;l++)t.push(random(o,i)),o+=e,i+=e;this.vertices=[];for(let e=0;e<this.numVertices;e++){let o=createVector(this.centre.x+this.distFromCentre*cos(t[e]),this.centre.y+this.distFromCentre*sin(t[e]));this.vertices.push(o)}this.facingDir=this.vertices[0].copy().sub(this.centre).normalize(),this.calculateEdges()}calculateEdges(){this.edges=[];for(let t=0;t<this.vertices.length;t++){let e=(t+1)%this.vertices.length;this.edges.push(this.vertices[e].copy().sub(this.vertices[t]))}}draw(){stroke(\"#fff4d6\"),strokeWeight(3),fill(this.color),beginShape();for(let t=0;t<this.numVertices;t++)vertex(this.vertices[t].x,this.vertices[t].y);endShape(CLOSE),this.controllable&&line(this.centre.x,this.centre.y,this.vertices[0].x,this.vertices[0].y)}move(){let t=0,e=0;if(keyIsDown(87)&&(t+=this.maxSpeed),keyIsDown(83)&&(t-=this.maxSpeed),keyIsDown(65)&&(e-=PI/48),keyIsDown(68)&&(e+=PI/48),0!==t||0!==e){this.target=null;let o=this.facingDir.copy().mult(t);this.centre.add(o);for(let t=0;t<this.vertices.length;t++){let i=this.vertices[t];i.add(o),i.sub(this.centre).rotate(e).add(this.centre)}return this.facingDir=this.vertices[0].copy().sub(this.centre).normalize(),void this.calculateEdges()}if(this.target&&p5.Vector.sub(this.target,this.centre).magSq()>100){let e=p5.Vector.sub(this.target,this.centre).normalize(),o=this.facingDir.angleBetween(e),i=constrain(o,-PI/48,PI/48);this.facingDir.rotate(i),t=this.maxSpeed;let l=this.facingDir.copy().mult(t);this.centre.add(l);for(let t=0;t<this.vertices.length;t++){let e=this.vertices[t];e.add(l),e.sub(this.centre).rotate(i).add(this.centre)}this.calculateEdges()}}moveBy(t){this.centre.add(t);for(let e=0;e<this.vertices.length;e++)this.vertices[e].add(t);this.calculateEdges()}update(){this.draw()}colliding(){this.movable&&!this.controllable&&(this.color=color(\"#fff4d6\"))}notColliding(){this.color=this.defaultColor}}const bgColor=\"#070831\";let polygonCount=10,polygons=[],controllablePolygon=null;function windowResized(){createCanvas(windowWidth,windowHeight),background(bgColor)}function setup(){createCanvas(windowWidth,windowHeight),polygons.push(new Polygon(createVector(300,300),5,100,100,3,!0,!0));for(let t=1;t<polygonCount;t++)polygons.push(new Polygon(createVector(random(50,windowWidth-50),random(50,windowHeight-50)),Math.floor(random(3,10)),random(50,100),random(5,100),random(5,10),!1,!0));controllablePolygon=polygons[0]}function touchStarted(){controllablePolygon&&(controllablePolygon.target=createVector(mouseX,mouseY))}function touchMoved(){controllablePolygon&&(controllablePolygon.target=createVector(mouseX,mouseY))}function touchEnded(){controllablePolygon&&(controllablePolygon.target=controllablePolygon.center)}function draw(){background(bgColor);for(let t of polygons)t.update();collisionCheck(),controllablePolygon.move()}function collisionCheck(){let t=new Set;for(let e=0;e<polygonCount;e++){polygons[e].notColliding();for(let o=e+1;o<polygonCount;o++){let i=satCollision(polygons[e],polygons[o]);i&&(t.add(e),t.add(o),collisionResolution(polygons[e],polygons[o],i))}}t.forEach((t=>polygons[t].colliding()))}function collisionResolution(t,e,o){staticResolve(t,e,o)}"
  }
}
